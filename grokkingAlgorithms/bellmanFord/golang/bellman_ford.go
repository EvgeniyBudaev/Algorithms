package main

import (
	"fmt"
	"math"
)

func main() {
	// Пример графа
	edges := []Edge{
		{0, 1, 4},
		{0, 2, 5},
		{1, 2, -2},
		{1, 3, 6},
		{2, 3, 1},
		{2, 4, 3},
		{3, 4, -1},
	}

	numVertices := 5 // Количество вершин в графе
	start := 0       // Вершина, от которой начинаем поиск

	// Вызываем алгоритм Беллмана-Форда
	dist, hasNegativeCycle := bellmanFord(edges, numVertices, start)

	if hasNegativeCycle {
		fmt.Println("Граф содержит отрицательный цикл!")
	} else {
		fmt.Println("Кратчайшие расстояния от вершины", start)
		for i, d := range dist {
			fmt.Printf("До вершины %d: ", i)
			if d == math.MaxInt32 {
				fmt.Println("недостижима")
			} else {
				fmt.Println(d)
			}
		}
	}
}

// Edge представляет ребро графа
type Edge struct {
	From, To int
	Weight   int
}

// bellmanFord реализует алгоритм Беллмана-Форда.
// Возвращает кратчайшие расстояния и флаг наличия отрицательного цикла.
// Временная сложность: O(V*E), где V - количество вершин, E - количество рёбер
// Пространственная сложность: O(V)
// Работает с отрицательными весами рёбер.
// Обнаруживает отрицательные циклы.
func bellmanFord(edges []Edge, numVertices, start int) ([]int, bool) {
	// Инициализация расстояний
	dist := make([]int, numVertices)
	for i := range dist {
		dist[i] = math.MaxInt32
	}
	// Устанавливаем расстояние от начальной вершины до самой себя равным 0
	dist[start] = 0

	// Релаксация всех рёбер V-1 раз
	for i := 0; i < numVertices-1; i++ {
		updated := false
		// Проходим по всем рёбрам и обновляем расстояния, если это возможно
		for _, edge := range edges {
			// Если расстояние до вершины из которой выходит ребро меньше бесконечности и расстояние до вершины,
			// которой входит ребро больше, чем сумма расстояния до вершины из которой выходит ребро и веса ребра,
			// то обновляем расстояние до вершины, которой входит ребро.
			if dist[edge.From] != math.MaxInt32 && dist[edge.To] > dist[edge.From]+edge.Weight {
				dist[edge.To] = dist[edge.From] + edge.Weight
				updated = true
			}
		}
		// Если на текущей итерации не было изменений, можно завершить раньше
		if !updated {
			break
		}
	}

	// Проверка на наличие отрицательных циклов
	for _, edge := range edges {
		// Если расстояние до вершины из которой выходит ребро меньше бесконечности и расстояние до вершины,
		// которой входит ребро больше, чем сумма расстояния до вершины из которой выходит ребро и веса ребра,
		// то есть обнаружен отрицательный цикл.
		if dist[edge.From] != math.MaxInt32 && dist[edge.To] > dist[edge.From]+edge.Weight {
			return nil, true // Обнаружен отрицательный цикл
		}
	}

	// Возвращаем кратчайшие расстояния и флаг отсутствия отрицательных циклов.
	return dist, false
}
