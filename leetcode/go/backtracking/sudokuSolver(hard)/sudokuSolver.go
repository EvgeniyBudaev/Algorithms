package main

import "strconv"

/* https://leetcode.com/problems/sudoku-solver/description/

Напишите программу, решающую судоку, заполняя пустые ячейки.

Решение судоку должно удовлетворять всем следующим правилам:

Каждая из цифр 1–9 должна встречаться ровно один раз в каждой строке.
Каждая из цифр 1–9 должна встречаться ровно один раз в каждом столбце.
Каждая из цифр 1–9 должна встретиться ровно один раз в каждом из 9 подполей сетки размером 3x3.
'.' символ указывает на пустые ячейки.

Input: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
*/

func main() {
	board := [][]byte{
		{'5', '3', '.', '.', '7', '.', '.', '.', '.'},
		{'6', '.', '.', '1', '9', '5', '.', '.', '.'},
		{'.', '9', '8', '.', '.', '.', '.', '6', '.'},
		{'8', '.', '.', '.', '6', '.', '.', '.', '3'},
		{'4', '.', '.', '8', '.', '3', '.', '.', '1'},
		{'7', '.', '.', '.', '2', '.', '.', '.', '6'},
		{'.', '6', '.', '.', '.', '.', '2', '8', '.'},
		{'.', '.', '.', '4', '1', '9', '.', '.', '5'},
		{'.', '.', '.', '.', '8', '.', '.', '7', '9'},
	}
	solveSudoku(board)
}

// solveSudoku решает переданную доску Sudoku (изменяет исходную доску)
func solveSudoku(board [][]byte) {
	dfs(board, 0, 0)
}

// isValid проверяет, можно ли разместить цифру в указанной клетке
func isValid(board [][]byte, row, col int, value byte) bool {
	// Проверяем строку
	for c := 0; c < 9; c++ {
		if board[row][c] == value {
			return false
		}
	}

	// Проверяем столбец
	for r := 0; r < 9; r++ {
		if board[r][col] == value {
			return false
		}
	}

	// Проверяем подблок 3x3
	startRow, startCol := (row/3)*3, (col/3)*3
	for r := startRow; r < startRow+3; r++ {
		for c := startCol; c < startCol+3; c++ {
			if board[r][c] == value {
				return false
			}
		}
	}

	return true
}

// dfs рекурсивно решает Sudoku с использованием backtracking
func dfs(board [][]byte, row, col int) bool {
	// Если дошли до конца доски - решение найдено
	if row == 9 {
		return true
	}
	// Если дошли до конца строки - переходим на следующую строку
	if col == 9 {
		return dfs(board, row+1, 0)
	}
	// Если клетка уже заполнена - переходим к следующей
	if board[row][col] != '.' {
		return dfs(board, row, col+1)
	}

	// Пробуем цифры от 1 до 9
	for num := 1; num <= 9; num++ {
		value := strconv.Itoa(num)[0] // Конвертируем число в byte
		if isValid(board, row, col, value) {
			board[row][col] = value
			if dfs(board, row, col+1) {
				return true
			}
			// Если решение не найдено - откатываем изменения
			board[row][col] = '.'
		}
	}

	return false
}
