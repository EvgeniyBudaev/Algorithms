package main

import "fmt"

/* 39. Combination Sum
https://leetcode.com/problems/combination-sum/description/

Учитывая массив различных целых чисел-кандидатов и целевую целочисленную цель, верните список всех уникальных комбинаций
кандидатов, в которых сумма выбранных чисел равна целевому значению. Вы можете возвращать комбинации в любом порядке.

Одно и то же число может быть выбрано из кандидатов неограниченное количество раз. Две комбинации уникальны, если
частота хотя бы одно из выбранных чисел отличается.

Тестовые примеры генерируются таким образом, чтобы количество уникальных комбинаций, дающих целевое значение, составляло
менее 150 комбинаций для данного входного сигнала.

Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Объяснение:
2 и 3 являются кандидатами, а 2 + 2 + 3 = 7. Обратите внимание, что 2 можно использовать несколько раз.
7 — кандидат, а 7 = 7.
Это единственные две комбинации.
*/

func main() {
	candidates := []int{2, 3, 6, 7}
	fmt.Println(combinationSum(candidates, 7)) // [[2,2,3],[7]]
}

// combinationSum находит все уникальные комбинации чисел из candidates,
// которые в сумме дают target. Одно и то же число может использоваться многократно.
// time: O(n^target) в худшем случае, где n — количество уникальных чисел в candidates.
// space: O(target) для хранения текущей комбинации и рекурсивных вызовов.
func combinationSum(candidates []int, target int) [][]int {
	var result [][]int // Здесь будем хранить все найденные комбинации

	// Внутренняя рекурсивная функция для генерации комбинаций
	var backtrack func(int, []int, int)
	backtrack = func(start int, current []int, sum int) {
		// Если сумма совпадает с целевой, добавляем комбинацию в результат
		if sum == target {
			// Создаем копию текущей комбинации
			temp := make([]int, len(current)) // Создаем копию текущей комбинации
			copy(temp, current)               // Копируем элементы в новый срез
			result = append(result, temp)     // Добавляем копию в результат
			return
		}
		// Если сумма превысила целевое значение или дошли до конца массива
		if sum > target || start >= len(candidates) {
			return
		}

		// Включаем текущий элемент в комбинацию (можно использовать многократно)
		current = append(current, candidates[start])     // Добавляем текущий элемент в комбинацию
		backtrack(start, current, sum+candidates[start]) // Не увеличиваем индекс

		// Исключаем текущий элемент (backtracking)
		current = current[:len(current)-1] // Удаляем последний элемент из комбинации
		backtrack(start+1, current, sum)   // Переходим к следующему элементу
	}

	backtrack(0, []int{}, 0) // Начинаем с первого элемента, пустой комбинации и суммы 0
	return result            // Возвращаем все найденные комбинации
}
