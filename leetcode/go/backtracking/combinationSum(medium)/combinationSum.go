package main

import "fmt"

/* https://leetcode.com/problems/combination-sum/description/

Учитывая массив различных целых чисел-кандидатов и целевую целочисленную цель, верните список всех уникальных комбинаций
кандидатов, в которых сумма выбранных чисел равна целевому значению. Вы можете возвращать комбинации в любом порядке.

Одно и то же число может быть выбрано из кандидатов неограниченное количество раз. Две комбинации уникальны, если
частота хотя бы одно из выбранных чисел отличается.

Тестовые примеры генерируются таким образом, чтобы количество уникальных комбинаций, дающих целевое значение, составляло
менее 150 комбинаций для данного входного сигнала.

Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Объяснение:
2 и 3 являются кандидатами, а 2 + 2 + 3 = 7. Обратите внимание, что 2 можно использовать несколько раз.
7 — кандидат, а 7 = 7.
Это единственные две комбинации.
*/

func main() {
	candidates := []int{2, 3, 6, 7}
	fmt.Println(combinationSum(candidates, 7)) // [[2,2,3],[7]]
}

// combinationSum находит все уникальные комбинации чисел из candidates,
// которые в сумме дают target. Одно и то же число может использоваться многократно.
func combinationSum(candidates []int, target int) [][]int {
	var result [][]int // Здесь будем хранить все найденные комбинации

	// Внутренняя рекурсивная функция для генерации комбинаций
	var backtrack func(int, []int, int)
	backtrack = func(start int, current []int, sum int) {
		// Если сумма совпадает с целевой, добавляем комбинацию в результат
		if sum == target {
			// Создаем копию текущей комбинации
			temp := make([]int, len(current))
			copy(temp, current)
			result = append(result, temp)
			return
		}
		// Если сумма превысила целевое значение или дошли до конца массива
		if sum > target || start >= len(candidates) {
			return
		}

		// Включаем текущий элемент в комбинацию (можно использовать многократно)
		current = append(current, candidates[start])
		backtrack(start, current, sum+candidates[start]) // Не увеличиваем индекс

		// Исключаем текущий элемент (backtracking)
		current = current[:len(current)-1]
		backtrack(start+1, current, sum) // Переходим к следующему элементу
	}

	backtrack(0, []int{}, 0) // Начинаем с первого элемента, пустой комбинации и суммы 0
	return result
}
