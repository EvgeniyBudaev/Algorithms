package main

import (
	"fmt"
	"sort"
)

/* 853. Car Fleet
https://leetcode.com/problems/car-fleet/description/

На расстоянии заданной мили от начальной мили 0 находится n автомобилей, которые едут, чтобы достичь целевой мили.
Вам заданы два целочисленных массива: позиция и скорость, оба длиной n, где позиция[i] — это стартовая миля i-го
автомобиля, а скорость[i] — скорость i-го автомобиля в милях в час.
Автомобиль не может обогнать другую машину, но может догнать ее и затем поехать рядом со скоростью более медленной
машины.
Автопарк – это автомобиль или автомобили, едущие рядом друг с другом. Скорость автопарка – это минимальная скорость
любого автомобиля в парке.
Если автомобиль догоняет автопарк на заданной миле, он все равно будет считаться частью автопарка.
Верните количество автопарков, которые прибудут в пункт назначения.

Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3
Explanation:
Автомобили, начинающиеся с 10 (скорость 2) и 8 (скорость 4), становятся автопарком, встречаясь друг с другом на 12.
Парк формируется у цели.
Автомобиль, стартующий с 0 (скорость 1), не догоняет ни один другой автомобиль, поэтому он сам по себе является
автопарком.
Автомобили, начинающиеся со скорости 5 (скорость 1) и 3 (скорость 3), становятся автопарком, встречаясь друг с другом на
скорости 6. Автопарк движется со скоростью 1, пока не достигнет цели.
*/

func main() {
	position := []int{10, 8, 0, 5, 3}              // Позиции автомобилей
	speed := []int{2, 4, 1, 1, 3}                  // Скорости автомобилей
	target := 12                                   // Расстояние в милях от начальной мили 0
	fmt.Println(carFleet(target, position, speed)) // 3
}

// carFleet вычисляет количество автопарков, которые прибудут в пункт назначения.
func carFleet(target int, position []int, speed []int) int {
	// Создаем пары позиция-скорость
	pairs := make([][2]int, len(position)) // [[10, 2] [8, 4] [0, 1] [5, 1] [3, 3]]
	for i := 0; i < len(position); i++ {
		pairs[i] = [2]int{position[i], speed[i]}
	}

	// Сортируем по позиции в порядке убывания
	sort.Slice(pairs, func(i, j int) bool { // [[10, 2] [8, 4] [5, 1] [3, 3] [0, 1]]
		return pairs[i][0] > pairs[j][0]
	})

	stack := []float64{} // Стек для хранения времени встречи с предыдущим автопарком
	for _, pair := range pairs {
		pos, spd := pair[0], pair[1]               // Позиция и скорость автомобиля
		time := float64(target-pos) / float64(spd) // Время встречи с предыдущим автопарком

		// Если текущий автомобиль догоняет предыдущий автопарк, он становится частью него
		if len(stack) == 0 || time > stack[len(stack)-1] {
			stack = append(stack, time)
		}
	}

	// Возвращаем количество автопарков
	return len(stack)
}
