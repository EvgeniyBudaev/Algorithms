package main

import "fmt"

/* https://leetcode.com/problems/next-greater-element-i/description/

Следующий больший элемент некоторого элемента x в массиве — это первый больший элемент, находящийся справа от x в том же
массиве.
Вам даны два различных целочисленных массива с нулевым индексом nums1 и nums2, где nums1 — это подмножество nums2.
Для каждого 0 <= i < nums1.length найдите индекс j такой, что nums1[i] == nums2[j] и определите следующий больший
элемент nums2[j] в nums2. Если следующего большего элемента нет, то ответом на этот запрос будет -1.
Верните массив ans длины nums1.length такой, что ans[i] является следующим большим элементом, как описано выше.

Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
Output: [-1,3,-1]
Объяснение: Следующий больший элемент для каждого значения nums1 выглядит следующим образом:
- 4 подчеркнуто в nums2 = [1,3,4,2]. Следующего большего элемента нет, поэтому ответ - -1.
- 1 подчеркнута в nums2 = [1,3,4,2]. Следующий больший элемент — 3.
- 2 подчеркнуто в nums2 = [1,3,4,2]. Следующего большего элемента нет, поэтому ответ - -1.

Input: nums1 = [2,4], nums2 = [1,2,3,4]
Output: [3,-1]
Объяснение: Следующий больший элемент для каждого значения nums1 выглядит следующим образом:
- 2 подчеркнуто в nums2 = [1,2,3,4]. Следующий больший элемент — 3.
- 4 подчеркнуто в nums2 = [1,2,3,4]. Следующего большего элемента нет, поэтому ответ - -1.
*/

func main() {
	nums1 := []int{4, 1, 2}
	nums2 := []int{1, 3, 4, 2}
	fmt.Println(nextGreaterElement(nums1, nums2)) // [-1,3,-1]
}

func nextGreaterElement(nums1 []int, nums2 []int) []int {
	stack := make([]int, 0)
	mapping := make(map[int]int)

	// Проходим nums2 справа налево
	for i := len(nums2) - 1; i >= 0; i-- {
		num := nums2[i]
		// Удаляем из стека все элементы меньшие или равные текущему
		for len(stack) > 0 && stack[len(stack)-1] <= num {
			stack = stack[:len(stack)-1]
		}
		// Записываем в маппинг следующий больший элемент (или -1)
		if len(stack) > 0 {
			mapping[num] = stack[len(stack)-1]
		} else {
			mapping[num] = -1
		}
		// Добавляем текущий элемент в стек
		stack = append(stack, num)
	}

	// Строим результат для nums1
	result := make([]int, len(nums1))
	for i, num := range nums1 {
		result[i] = mapping[num]
	}

	return result
}
