package main

import (
	"fmt"
	"math"
)

/* https://leetcode.com/problems/house-robber-ii/description/

Вы профессиональный грабитель, планирующий грабить дома на улице. В каждом доме хранится определенная сумма денег.
Все дома в этом месте расположены по кругу. Это означает, что первый дом является соседом последнего.
При этом в соседних домах подключена система безопасности, и она автоматически обратится в полицию, если в одну ночь
были взломаны два соседних дома.
Учитывая целочисленный массив чисел, представляющий сумму денег в каждом доме, верните максимальную сумму денег,
которую вы можете ограбить сегодня вечером, не предупредив полицию.

Input: nums = [2,3,2]
Output: 3
Пояснение: Вы не можете ограбить дом 1 (деньги = 2), а затем ограбить дом 3 (деньги = 2), потому что это соседние дома

Input: nums = [1,2,3,1]
Output: 4
Пояснение: Ограбить дом 1 (деньги = 1), а затем ограбить дом 3 (деньги = 3).
Общая сумма, которую вы можете ограбить = 1 + 3 = 4.

Input: nums = [1,2,3]
Output: 3
*/

func main() {
	fmt.Println(rob([]int{2, 3, 2}))
}

// rob вычисляет максимальную сумму для ограбления домов на кольцевой улице
func rob(nums []int) int {
	n := len(nums)
	// Обрабатываем особые случаи для массивов длиной менее 4
	if n == 0 {
		return 0
	}
	if n < 4 {
		return maxInSlice(nums)
	}

	// Вспомогательная функция для расчета максимальной суммы на отрезке
	robberHelper := func(start, end int) int {
		prev, beforePrev := 0, 0
		for i := start; i < end; i++ {
			// Сохраняем предыдущее значение
			tmp := prev
			// Вычисляем новое значение как максимум:
			// - ограбление текущего дома + beforePrev
			// - или пропуск текущего дома (prev)
			prev = int(math.Max(float64(nums[i]+beforePrev), float64(prev)))
			beforePrev = tmp
		}
		return prev
	}

	// Возвращаем максимум из двух вариантов:
	// 1. Грабим первый дом, но не последний
	// 2. Грабим последний дом, но не первый
	return int(math.Max(
		float64(robberHelper(0, n-1)),
		float64(robberHelper(1, n)),
	))
}

// maxInSlice возвращает максимальное значение в срезе
func maxInSlice(nums []int) int {
	maxNum := nums[0]
	for _, num := range nums {
		if num > maxNum {
			maxNum = num
		}
	}
	return maxNum
}
