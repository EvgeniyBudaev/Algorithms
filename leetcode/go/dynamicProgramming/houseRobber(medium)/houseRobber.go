package main

import (
	"fmt"
	"math"
)

/* https://leetcode.com/problems/house-robber/description/

Вы профессиональный грабитель, планирующий грабить дома на улице. В каждом доме спрятана определенная сумма денег,
единственное ограничение, которое удерживает вас от ограбления каждого из них, это то, что в соседних домах подключены
системы безопасности, и они автоматически свяжутся с полицией, если в одну ночь взломали два соседних дома.
Учитывая целочисленный массив чисел, представляющий сумму денег в каждом доме, верните максимальную сумму денег,
которую вы можете ограбить сегодня вечером, не предупредив полицию.

Input: nums = [1,2,3,1]
Output: 4
Пояснение: Ограбить дом 1 (деньги = 1), а затем ограбить дом 3 (деньги = 3).
Общая сумма, которую вы можете ограбить = 1 + 3 = 4.

Input: nums = [2,7,9,3,1]
Output: 12
Пояснение: Ограбить дом 1 (деньги = 2), ограбить дом 3 (деньги = 9) и ограбить дом 5 (деньги = 1).
Общая сумма, которую вы можете ограбить = 2 + 9 + 1 = 12.
*/

func main() {
	fmt.Println(rob([]int{1, 2, 3, 1}))
}

// rob вычисляет максимальную сумму, которую можно украсть, не грабя два соседних дома
func rob(nums []int) int {
	// rob - максимальная сумма при ограблении текущего дома
	// norob - максимальная сумма без ограбления текущего дома
	rob, norob := 0, 0

	for _, num := range nums {
		// newRob - сумма если грабим текущий дом:
		// нельзя грабить предыдущий, поэтому берем norob + текущий дом
		newRob := norob + num

		// newNoRob - если не грабим текущий дом:
		// берем максимум из предыдущих вариантов (грабили или не грабили предыдущий дом)
		newNoRob := int(math.Max(float64(norob), float64(rob)))

		// Обновляем значения для следующей итерации
		rob, norob = newRob, newNoRob
	}

	// Возвращаем максимальную из двух возможных сумм
	return int(math.Max(float64(rob), float64(norob)))
}
