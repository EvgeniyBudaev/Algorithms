package main

import (
	"fmt"
	"sort"
)

/* 2389. Longest Subsequence With Limited Sum
https://leetcode.com/problems/longest-subsequence-with-limited-sum/description/

Вам дан целочисленный массив nums длины n и запросы целочисленного массива queries длиной m.
Верните answer в виде массива длиной m, где answer[i] — максимальный размер подпоследовательности, которую можно взять
из чисел, чтобы сумма ее элементов была меньше или равна запросу [i].
Подпоследовательность — это массив, который можно получить из другого массива путем удаления некоторых элементов или их
отсутствия без изменения порядка остальных элементов.

Input: nums = [4,5,2,1], queries = [3,10,21]
Output: [2,3,4]
Пояснение: На запросы мы отвечаем следующим образом:
- Сумма подпоследовательности [2,1] меньше или равна 3. Можно доказать, что 2 — максимальный размер такой
подпоследовательности, поэтому answer[0] = 2.
- Сумма подпоследовательности [4,5,1] меньше или равна 10. Можно доказать, что 3 — максимальный размер такой
подпоследовательности, поэтому answer[1] = 3.
- Сумма подпоследовательности [4,5,2,1] меньше или равна 21. Можно доказать, что 4 — это максимальный размер такой
подпоследовательности, поэтому answer[2] = 4. 4.

Input: nums = [2,3,4,5], queries = [1]
Output: [0]
Объяснение: Пустая подпоследовательность — единственная подпоследовательность, сумма которой меньше или равна 1,
поэтому ответ[0] = 0.
*/

func main() {
	nums := []int{4, 5, 2, 1}
	queries := []int{3, 10, 21}
	fmt.Println(answerQueries(nums, queries)) // [2,3,4]
}

// answerQueries возвращает массив с максимальным размером подпоследовательности для каждого запроса.
func answerQueries(nums []int, queries []int) []int {
	// Сортируем массив чисел по возрастанию
	sort.Ints(nums) // [1, 2, 4, 5]

	// Создаем префиксную сумму для оптимизации
	prefix := make([]int, len(nums)+1)
	for i := 0; i < len(nums); i++ {
		// Заполняем префиксную сумму текущим числом и предыдущей суммой
		prefix[i+1] = prefix[i] + nums[i]
	}

	// Создаем массив ответов с размером запросов
	result := make([]int, len(queries))
	for i, query := range queries {
		// Используем бинарный поиск для нахождения максимального размера подпоследовательности для текущего запроса
		left, right := 0, len(prefix)
		for left < right {
			mid := (left + right) / 2
			// Если сумма префикса больше текущего запроса, уменьшаем правую границу
			if prefix[mid] > query {
				right = mid
			} else {
				left = mid + 1
			}
		}
		result[i] = left - 1
	}

	// Возвращаем массив ответов
	return result
}
