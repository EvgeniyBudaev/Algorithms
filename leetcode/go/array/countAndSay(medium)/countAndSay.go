package main

import (
	"fmt"
	"strconv"
)

/* 38. Count and Say
https://leetcode.com/problems/count-and-say/description/

Последовательность count-and-say — это последовательность строк цифр, определяемая рекурсивной формулой:

countAndSay(1) = "1"
countAndSay(n) — это кодирование длины серии countAndSay(n - 1).
Кодирование длины серии (RLE) — это метод сжатия строк, который работает путем замены последовательных одинаковых
символов (повторяющихся 2 или более раз) на конкатенацию символа и числа, обозначающего количество символов
(длину серии). Например, чтобы сжать строку "3322251", мы заменяем "33" на "23", заменяем "222" на "32",
заменяем "5" на "15" и заменяем "1" на "11". Таким образом, сжатая строка становится "23321511".

Дано положительное целое число n, вернуть n-й элемент последовательности count-and-say.

Input: n = 4
Output: "1211"

Explanation:
countAndSay(1) = "1"
countAndSay(2) = RLE of "1" = "11"
countAndSay(3) = RLE of "11" = "21"
countAndSay(4) = RLE of "21" = "1211"
*/

func main() {
	fmt.Println(countAndSay(4)) // "1211"
}

// countAndSay возвращает строку, представляющую n-й элемент последовательности count-and-say.
// time: O(n*m), где n — входное число, а m — длина строки в последовательности count-and-say.
// space: O(n*m)
func countAndSay(n int) string {
	res := "1" // Начинаем с первого элемента последовательности

	for n > 1 { // Пока n больше 1, продолжаем генерировать последовательность
		cur := ""          // Текущая строка
		i := 0             // Индекс текущего символа
		for i < len(res) { // Проходим по всем символам в текущей строке
			count := 1                                 // Количество текущего символа
			for i+1 < len(res) && res[i] == res[i+1] { // Если текущий символ равен следующему, увеличиваем счетчик
				i++     // Переходим к следующему символу
				count++ // Увеличиваем счетчик
			}
			cur += strconv.Itoa(count) + string(res[i]) // Добавляем количество и текущий символ в текущую строку
			i++                                         // Переходим к следующему символу
		}
		res = cur // Обновляем текущую строку
		n--       // Уменьшаем счетчик n на 1
	}

	// Возвращаем результат
	return res
}
