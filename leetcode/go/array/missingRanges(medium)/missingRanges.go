package main

import "fmt"

/* 163. Missing Ranges
https://leetcode.ca/2016-05-11-163-Missing-Ranges/

Вам дан инклюзивный диапазон [нижний, верхний] и отсортированный уникальный целочисленный массив nums, где все элементы
находятся в пределах инклюзивного диапазона.

Число x считается отсутствующим, если x находится в диапазоне [нижний, верхний] и x не находится в nums.

Верните кратчайший отсортированный список диапазонов, который точно охватывает все отсутствующие числа. То есть ни один
элемент nums не включен ни в один из диапазонов, и каждое отсутствующее число покрывается одним из диапазонов.

Input: nums = [0,1,3,50,75], lower = 0, upper = 99
Output: [[2,2],[4,49],[51,74],[76,99]]
Explanation: The ranges are:
[2,2]
[4,49]
[51,74]
[76,99]
*/

func main() {
	nums := []int{0, 1, 3, 50, 75}
	fmt.Println(findMissingRanges(nums, 0, 99)) // [[2,2],[4,49],[51,74],[76,99]]
}

// findMissingRanges - возвращает кратчайший отсортированный список диапазонов, который точно охватывает все отсутствующие числа.
// Time: O(n), Space: O(n)
func findMissingRanges(nums []int, lower int, upper int) [][]int {
	n := len(nums) // количество чисел в массиве
	var result [][]int
	if n == 0 { // если массив пустой
		return [][]int{{lower, upper}} // вернуть диапазон от нижнего до верхнего
	}

	if nums[0] > lower { // если первый элемент массива больше нижнего
		result = append(result, []int{lower, nums[0] - 1}) // добавить диапазон от нижнего до первого элемента массива минус 1
	}

	for i, b := range nums[1:] { // проход по массиву от второго элемента до последнего
		if a := nums[i]; b-a > 1 { // если разница между текущим и предыдущим элементами больше 1
			result = append(result, []int{a + 1, b - 1}) // добавить диапазон от предыдущего элемента массива плюс 1 до текущего минус 1
		}
	}

	if nums[n-1] < upper { // если последний элемент массива меньше верхнего
		result = append(result, []int{nums[n-1] + 1, upper}) // добавить диапазон от последнего элемента массива плюс 1 до верхнего
	}

	return result // вернуть список диапазонов
}
