package main

import (
	"fmt"
	"sort"
)

/* 452. Minimum Number of Arrows to Burst Balloons
https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/

К плоской стене, представляющей плоскость XY, приклеено несколько сферических воздушных шаров. Выноски представлены в
виде двумерного целочисленного массива точек, где points[i] = [xstart, xend] обозначает выноску, горизонтальный диаметр
которой простирается между xstart и xend. Вы не знаете точных координат Y воздушных шаров.

Стрелки можно стрелять прямо вертикально (в положительном направлении Y) из разных точек вдоль оси X. Воздушный шар с
xstart и xend разрывается стрелой, выпущенной в x, если xstart <= x <= xend. Нет ограничений на количество выпущенных
стрел. Выпущенная стрела продолжает двигаться вверх бесконечно, разрывая все воздушные шары на своем пути.

Учитывая точки массива, верните минимальное количество стрел, которое необходимо выпустить, чтобы лопнуть все
воздушные шары.

Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Пояснение: Воздушные шары можно лопнуть двумя стрелами:
- Выстрелите стрелой в точку x = 6, лопнув шарики [2,8] и [1,6].
- Выстрелите стрелой в точку x = 11, лопнув шарики [10,16] и [7,12].
*/

func main() {
	points := [][]int{{10, 16}, {2, 8}, {1, 6}, {7, 12}}
	fmt.Println(findMinArrowShots(points)) // 2
}

// findMinArrowShots находит минимальное количество стрел, которое необходимо выпустить, чтобы лопнуть все воздушные шары.
// time: O(n), space: O(1)
func findMinArrowShots(points [][]int) int {
	// Если нет интервалов, то нет стрел
	if len(points) == 0 {
		return 0
	}

	// Сортируем интервалы по конечной точке
	sort.Slice(points, func(i, j int) bool {
		return points[i][1] < points[j][1]
	})
	// points: [[1 6] [2 8] [7 12] [10 16]]

	arrows := 1             // Первый интервал всегда лопнется стрелой
	lastEnd := points[0][1] // Последняя точка конца

	for i := 1; i < len(points); i++ { // Перебираем оставшиеся интервалы
		// Если текущий интервал не пересекается с последним, нужна новая стрела
		if points[i][0] > lastEnd {
			arrows++               // Добавляем стрелу
			lastEnd = points[i][1] // Обновляем последнюю точку конца
		}
	}

	return arrows // Возвращаем количество стрел
}
