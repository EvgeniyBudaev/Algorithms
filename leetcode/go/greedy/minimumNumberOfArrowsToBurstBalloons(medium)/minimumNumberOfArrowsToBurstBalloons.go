package main

import (
	"fmt"
	"sort"
)

/* https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/

К плоской стене, представляющей плоскость XY, приклеено несколько сферических воздушных шаров. Выноски представлены в
виде двумерного целочисленного массива точек, где points[i] = [xstart, xend] обозначает выноску, горизонтальный диаметр
которой простирается между xstart и xend. Вы не знаете точных координат Y воздушных шаров.

Стрелки можно стрелять прямо вертикально (в положительном направлении Y) из разных точек вдоль оси X. Воздушный шар с
xstart и xend разрывается стрелой, выпущенной в x, если xstart <= x <= xend. Нет ограничений на количество выпущенных
стрел. Выпущенная стрела продолжает двигаться вверх бесконечно, разрывая все воздушные шары на своем пути.

Учитывая точки массива, верните минимальное количество стрел, которое необходимо выпустить, чтобы лопнуть все
воздушные шары.

Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Пояснение: Воздушные шары можно лопнуть двумя стрелами:
- Выстрелите стрелой в точку x = 6, лопнув шарики [2,8] и [1,6].
- Выстрелите стрелой в точку x = 11, лопнув шарики [10,16] и [7,12].
*/

func main() {
	points := [][]int{{10, 16}, {2, 8}, {1, 6}, {7, 12}}
	fmt.Println(findMinArrowShots(points)) // 2
}

func findMinArrowShots(points [][]int) int {
	if len(points) == 0 {
		return 0
	}

	// Сортируем интервалы по конечной точке
	sort.Slice(points, func(i, j int) bool {
		return points[i][1] < points[j][1]
	})

	arrows := 1
	lastEnd := points[0][1]

	for i := 1; i < len(points); i++ {
		// Если текущий интервал не пересекается с последним, нужна новая стрела
		if points[i][0] > lastEnd {
			arrows++
			lastEnd = points[i][1]
		}
	}

	return arrows
}
