package binarySearch.LongestSubsequenceWithLimitedSum;

import java.util.Arrays;

/* 2389. Longest Subsequence With Limited Sum
https://leetcode.com/problems/longest-subsequence-with-limited-sum/description/

Вам дан целочисленный массив nums длины n и запросы целочисленного массива queries длиной m.
Верните answer в виде массива длиной m, где answer[i] — максимальный размер подпоследовательности, которую можно взять
из чисел, чтобы сумма ее элементов была меньше или равна запросу [i].
Подпоследовательность — это массив, который можно получить из другого массива путем удаления некоторых элементов или их
отсутствия без изменения порядка остальных элементов.

Input: nums = [4,5,2,1], queries = [3,10,21]
Output: [2,3,4]
Пояснение: На запросы мы отвечаем следующим образом:
- Сумма подпоследовательности [2,1] меньше или равна 3. Можно доказать, что 2 — максимальный размер такой
подпоследовательности, поэтому answer[0] = 2.
- Сумма подпоследовательности [4,5,1] меньше или равна 10. Можно доказать, что 3 — максимальный размер такой
подпоследовательности, поэтому answer[1] = 3.
- Сумма подпоследовательности [4,5,2,1] меньше или равна 21. Можно доказать, что 4 — это максимальный размер такой
подпоследовательности, поэтому answer[2] = 4. 4.

Input: nums = [2,3,4,5], queries = [1]
Output: [0]
Объяснение: Пустая подпоследовательность — единственная подпоследовательность, сумма которой меньше или равна 1,
поэтому ответ[0] = 0.
*/

public class LongestSubsequenceWithLimitedSum {
    public static void main(String[] args) {
        int[] nums = {4, 5, 2, 1};
        int[] queries = {3, 10, 21};
        System.out.println(Arrays.toString(answerQueries(nums, queries))); // [2, 3, 4]
    }

    // answerQueries возвращает массив с максимальным размером подпоследовательности для каждого запроса.
    private static int[] answerQueries(int[] nums, int[] queries) {
        // Сортируем массив чисел по возрастанию
        Arrays.sort(nums); // [1, 2, 4, 5]

        // Создаем префиксную сумму для оптимизации
        int[] prefix = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            // Заполняем префиксную сумму текущим числом и предыдущей суммой
            prefix[i + 1] = prefix[i] + nums[i];
        }

        // Создаем массив ответов с размером запросов
        int[] result = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            int query = queries[i];
            // Используем бинарный поиск для нахождения максимального размера подпоследовательности для текущего запроса
            int left = 0;
            int right = prefix.length;
            while (left < right) {
                int mid = (left + right) / 2;
                // Если сумма префикса больше текущего запроса, уменьшаем правую границу
                if (prefix[mid] > query) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            // Уменьшаем индекс на 1, так как мы ищем максимальный размер подпоследовательности,
            // которая суммируется до текущего запроса
            result[i] = left - 1;
        }

        // Возвращаем массив ответов
        return result;
    }
}
