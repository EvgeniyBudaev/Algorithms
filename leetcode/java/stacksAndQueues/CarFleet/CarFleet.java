package stacksAndQueues.CarFleet;

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;

/* 853. Car Fleet
https://leetcode.com/problems/car-fleet/description/

На расстоянии заданной мили от начальной мили 0 находится n автомобилей, которые едут, чтобы достичь целевой мили.
Вам заданы два целочисленных массива: позиция и скорость, оба длиной n, где позиция[i] — это стартовая миля i-го
автомобиля, а скорость[i] — скорость i-го автомобиля в милях в час.
Автомобиль не может обогнать другую машину, но может догнать ее и затем поехать рядом со скоростью более медленной
машины.
Автопарк – это автомобиль или автомобили, едущие рядом друг с другом. Скорость автопарка – это минимальная скорость
любого автомобиля в парке.
Если автомобиль догоняет автопарк на заданной миле, он все равно будет считаться частью автопарка.
Верните количество автопарков, которые прибудут в пункт назначения.

Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3
Explanation:
Автомобили, начинающиеся с 10 (скорость 2) и 8 (скорость 4), становятся автопарком, встречаясь друг с другом на 12.
Парк формируется у цели.
Автомобиль, стартующий с 0 (скорость 1), не догоняет ни один другой автомобиль, поэтому он сам по себе является
автопарком.
Автомобили, начинающиеся со скорости 5 (скорость 1) и 3 (скорость 3), становятся автопарком, встречаясь друг с другом на
скорости 6. Автопарк движется со скоростью 1, пока не достигнет цели.
*/

public class CarFleet {
    public static void main(String[] args) {
        int[] position = {10, 8, 0, 5, 3}; // Позиции автомобилей
        int[] speed = {2, 4, 1, 1, 3};     // Скорости автомобилей
        int target = 12;                   // Расстояние в милях от начальной мили 0
        System.out.println(carFleet(target, position, speed)); // 3
    }

    // carFleet вычисляет количество автопарков, которые прибудут в пункт назначения.
    private static int carFleet(int target, int[] position, int[] speed) {
        int n = position.length;
        // Создаем массив пар [позиция, скорость]
        int[][] pairs = new int[n][2];
        for (int i = 0; i < n; i++) {
            pairs[i][0] = position[i];
            pairs[i][1] = speed[i];
        }
        // [[10, 2] [8, 4] [0, 1] [5, 1] [3, 3]]

        // Сортируем по позиции в порядке убывания
        Arrays.sort(pairs, (a, b) -> Integer.compare(b[0], a[0]));
        // [[10, 2] [8, 4] [5, 1] [3, 3] [0, 1]]

        // Стек для хранения времени встречи с предыдущим автопарком
        Deque<Double> stack = new ArrayDeque<>();

        for (int[] pair : pairs) {
            int pos = pair[0]; // Позиция автомобиля
            int spd = pair[1]; // Скорость автомобиля
            double time = (double) (target - pos) / spd; // Время встречи с предыдущим автопарком

            // Если текущий автомобиль догоняет предыдущий автопарк, он становится частью него
            if (stack.isEmpty() || time > stack.peek()) {
                stack.push(time);
            }
        }

        return stack.size(); // Возвращаем количество автопарков
    }
}
