/* 2636.Promise Pool
https://github.com/EvgeniyBudaev/doocs_leetcode/blob/main/solution/2600-2699/2636.Promise%20Pool/README.md

Напишите, пожалуйста, асинхронную функцию promisePool, которая получает массив асинхронных функций functions и
ограничение пула n. Он должен возвращать объект-обещание, которое будет выполнено после выполнения всех входных функций.

Ограничение пула определяется как максимальное количество объектов-обещаний, которые могут находиться в ожидании
одновременно. promisePool следует начать выполнять как можно больше функций и продолжить выполнение новых функций
после того, как старое обещание будет выполнено. promisePool cначала следует выполнить functions[i], затем выполнить
functions[i + 1], затем выполнить  functions[i + 2]и т. д. Когда последнее обещание будет выполнено, promisePool оно
также должно быть выполнено.

Например, если n = 1, promisePool функция выполняется по одной в последовательности. Однако если n = 2 он сначала
выполняет две функции. Когда выполнение любой из двух функций завершается, выполняется третья функция (если она
доступна) и так далее, пока не останется функций для выполнения.

Можно предположить, что functions не все будут отвергнуты. promisePool допустимо возвращать обещание, которое принимает
любое значение.

Input:
функции = [
    () => new Promise(res => setTimeout (res, 300)),
    () => new Promise(res => setTimeout (res, 400)),
    () => new Promise(res => setTimeout (res, 200))
];
n=2
Output: [[300,400,500],500]
Объяснение:
Передаются три функции. Их время сна составляет 300 мс, 400 мс и 200 мс соответственно.
При t=0 выполняются первые две функции. Ограничение размера пула достигает 2.
Когда t=300, после выполнения первой функции выполняется третья функция. Размер бассейна — 2 человека.
При t=400, после выполнения второй функции. Больше нечего делать. Размер бассейна 1.
При t=500, после выполнения третьей функции. Размер пула равен 0, поэтому возвращенное обещание также выполняется.
*/

function promisePool(functions, n) {
    const wrappers = functions.map(fn => async () => {
        await fn();
        const nxt = waiting.shift();
        nxt && (await nxt());
    });

    const running = wrappers.slice(0, n);
    const waiting = wrappers.slice(n);
    return Promise.all(running.map(fn => fn()));
}

const func = [
    () => new Promise(res => setTimeout (res, 300)),
    () => new Promise(res => setTimeout (res, 400)),
    () => new Promise(res => setTimeout (res, 200))
];
console.log(promisePool(func, 2)); // [[300,400,500],500]