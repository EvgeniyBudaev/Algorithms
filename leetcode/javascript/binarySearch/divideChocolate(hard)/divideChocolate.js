/* 1231. Divide Chocolate

У вас есть одна плитка шоколада, состоящая из нескольких кусочков. Каждый кусок имеет свою сладость, определяемую
сладостью массива.
Вы хотите поделиться шоколадом со своими K друзьями, поэтому начинаете разрезать плитку шоколада на K+1 кусочков,
используя K разрезов, каждый кусок состоит из нескольких последовательных кусков.
Проявив щедрость, вы съедите кусок с минимальной общей сладостью, а остальные кусочки раздадите друзьям.
Найдите максимальную общую сладость кусочка, которую вы можете получить, оптимально разрезав плитку шоколада.

Input: sweetness = [1,2,3,4,5,6,7,8,9], K = 5
Output: 6
Пояснение: Вы можете разделить шоколад на [1,2,3], [4,5], [6], [7], [8], [9]

Input: sweetness = [5,6,7,8,9,1,2,3,4], K = 8
Output: 1
Пояснение: Разрезать брусок на 9 частей можно только одним способом.

Input: sweetness = [1,2,2,1,2,2,1,2,2], K = 2
Output: 5
Пояснение: Вы можете разделить шоколад на [1,2,2], [1,2,2], [1,2,2]
*/

/**
 * @param {number[]} sweetness
 * @param {number} k
 * @return {number}
 */
function maximizeSweetness(sweetness, k) {
    let left = 0; // Инициализировать нижнюю границу бинарного поиска
    let right = sweetness.reduce((a, b) => a + b); // Инициализируйте верхнюю границу как сумму сладости

    // Определим вспомогательную функцию, чтобы проверить, можно ли разделить массив сладостей
    // на более чем k частей, где каждая часть имеет минимальную общую сладость x
    const canSplit = (minimumSweetness) => {
        let currentSweetness = 0;
        let partsCount = 0;
        for (const value of sweetness) {
            currentSweetness += value; // Добавьте значение сладости к текущей сумме
            // Если текущая сумма достигает минимального порога сладости, мы начинаем новую часть
            if (currentSweetness >= minimumSweetness) {
                currentSweetness = 0; // Сбросить текущую сладость для следующей части
                partsCount++; // Увеличить количество деталей
            }
        }
        // Проверяем, можем ли мы иметь более k частей с указанной минимальной сладостью.
        return partsCount > k;
    };

    // Используйте бинарный поиск, чтобы найти максимальную минимальную сладость.
    while (left < right) {
        const mid = Math.floor((left + right + 1) / 2);
        // Если возможно разделить более чем на k частей с минимальной сладостью в середине,
        // это означает, что мы можем попробовать более высокий минимум. Итак, мы обновляем слева до середины.
        if (canSplit(mid)) left = mid;
        // В противном случае нужно искать меньшую минимальную сладость.
        else right = mid - 1;
    }
    // После двоичного поиска слева будет максимальная минимальная сладость, которую мы можем достичь.
    return left;
}

const sweetness = [1,2,3,4,5,6,7,8,9];
console.log(maximizeSweetness(sweetness, 5)); // 6